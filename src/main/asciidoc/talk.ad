= Software Development in the 21st century
:icons: font
:twitter-tag: @jensschauder
:conference-tag:
:talk-tag: #sw21cent
:slide-link: http://bit.ly/sd-21-cent
:linkattrs:

include::footer.ad[]

== Not News!

"The best Softwareengineering Tips from the 60s, 70s and 80s"

=== We are living in a Software crisis

=== The computers are too big!

[quote, Edsger Dijkstra, The Humble Programmer (EWD340), Communications of the ACM 1972]
____
as long as there were no machines, programming was no problem at all;
when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem.
____

=== How gigantic?

PDP-11 (1970)

1 CPU

256 kB

10 MHz

I call that 1 CSU (Computer Size Unit)

=== My phone

8 Cores

4 GB

2 GHz

8 * 4000 * 200 CSU = 64.000.000 CSU

=== You have a garden

=== 15m x 15m

=== You inherit more

=== 75m x 75m

You can't handle it!

=== Now Germany is your Garden!

=== Or Europe

[NOTE.speaker]
====
if you are running in the Cloud
====

== Software Engineering!

image::margaret-hamilton.jpg[background, size=contain]

[NOTE.speaker]
====
Margaret Hamilton coined the term to add value to the profession.

It's all about professionalizing the job.
====

=== Nato Conference.

=== Minor improvements in the decades since.

=== !

[quote, Frei nach Kevlin Henney]
____
Die IT entdeckt nicht ständig etwas Neues. Wir vergessen bloß was wir schon längst wussten und finden es dann wieder.
____


== Werkzeuge

=== Wir brauchen

=== Editor oder IDE

=== Versions Verwaltung

=== Git oder Gitartige

=== Auch für

* Dokumentation
* Datenbankskripte

=== Issue Tracker

=== Referenzen zwischen Commits und Issues

=== Automatisierte Tests

=== Continuous Integration

=== Dependency Management

[NOTE.speaker]
====
Maven oder vergleichbares.
====


== Software Design

=== Modularisierung

=== !

[quote, Christopher Alexander, Notes on the Syntesis of Form, 1964]
____
We may therefore picture the process of formmaking as the action of a series of subsystems, all interlinked, yet sufficiently free of one another to adjust independently in a feasilbe amount of time. It works, because the cycles of correction and recorrection, which occur during adaptation, are restricted to one subsystem at a time.
____

=== !

[quote, Parnas, On the Criteria To Be Used in Decomposing Systems into Modules, 1972]
____
It is almost always incorrect to begin the decomposition
of a system into modules on the basis of a flowchart.
____

=== Flowchart einer Webapplikation

=== Package Struktur

=== !

[quote, Parnas, On the Criteria To Be Used in Decomposing Systems into Modules, 1972]
____
instead that one begins with a list of
difficult design decisions or design decisions which are
likely to change. Each module is then designed to hide
such a decision from the others.
____

[NOTE.speaker]
====
Was genau ist ein Kunde, ein Auftrag, eine Bestellung?

Irgend wann auch:

 Wie ist meine Datenbank strukturiert.
 Welche Art von Datenbank verwende ich?
====

=== Packages, Klassen, Methoden als Baum

// todo image

=== Wo ändert sich etwas?

// todo image

=== Oder so?

// todo image

=== Ein Rant in Sachen Reuse.

[NOTE.speaker]
====
Reuse ist teuer.

Es ist eine Investition.

Baut sauber strukturierte Code, dann ist reuse möglich, wenn nötig.
====

=== ~99% reuse

[NOTE.speaker]
====
We are actually pretty good at reuse
====

=== Build a VW Golf

With parts from Bulldozers and Windfarms

+

15kg custom parts

== Prozesse, Menschen und komplexe Systeme

=== Classical PM builds on core assumptions.

=== You can employ central control.

=== Design is the hard part.

=== Implementing the design takes long.

=== Lots of simple tasks.

=== Lots of repetitive tasks.

=== You can define "done" without use.

=== Change is expensive

=== All but one are wrong.

=== Software Development is complex.

[NOTE.speaker]
====
Minute details can have huge effects.

* A talk a team member watched.
* A fight a team member had at home.
* A feature that got added or not.

You can't predict the future from the past.
====


=== !

[quote, Cilliers, Paul, "Knowing Complex Systems" Managing organizational complexity : philosophy, theory and application. - Greenwich, Conn. : IAP - Information Age Pub. Inc, ISBN 1593113196. - 2005, p. 7-19]
____
There is no accurate (or rather, perfect) representation of the system which is simpler than the system itself.
____

=== Design is still hard.

[NOTE.speaker]
====
The largest part of software design happens during coding.
====

=== Implementing the design is easy.

It's called compiling.

=== !

[quote, NATO Software Engineering Conference 1968]
____
The replicastion of multiple copies of a software system is the phase of software manufacture which corresponds to the production phase in other areas of engineering.
____

=== There are few simple tasks.

=== There are no repetitive tasks.

[NOTE.speaker]
====
Simple repetitive tasks get bundled into two tasks.

- creating a generic solution.
- using the solution.

One task is pretty hard, the other is trivial and is done while slurping the morning coffee.
====

=== Software is done when it's used.

[NOTE.speaker]
====
Verification: Matches specification.
Validation: Is fit for intended use.
====

=== Change of software can be cheap

[NOTE.speaker]
====
Tests and clean code
====

== Alternativen

===!

=== Iterativ und Inkrementell

[quote, E. E. David, NATO Software Engineering Conference, 1968]
____
Define a subset of the system which is small enough to bring to an operational state [...] then build on that subsystem.
____

=== Vermeidet parallele Arbeit.

=== Laufenburg Bridge

[NOTE.speaker]
====
Lot's of planning which tried to solve a difficult problem (aligning a marble slab in Amsterdam with a rock in Switzerland).
And got it wrong.
If you build just from one side the problem goes away because you can aim at the target height directly.
In software this is very often rather easy.
====

=== Simplicity

[quote, Kent Beck, Extreme Programming explained]
____
What is the simplest thing that could possibly work?
____

=== Feedback

[quote, NATO Software Engineering Conference 1968]
____
The need for feedback was stressed many times.
____

=== !

[quote, Alan Perlis]
____
A software system can best be designed if the testing is interlaced with the designing instead of being used after the design.
____

=== !

[quote, NATO Software Engineering Conference 1968]
____
1. Flowchart until you think you understand the problem.
2. Write code until you realize that you don’t.
3. Go back and re-do the flowcharting.
4. Write some more code and iterate to what you feel is the correct solution.
____

=== Unit Tests instead of Experimenting.

Minutes -> Subseconds.

=== Integration Tests instead of Manual Tests

Weeks, Months -> Seconds.

=== Retrospectives

Months, Years -> Weeks.

=== Daily Standups.

??? -> Day.

=== Frequent Deployments.

Months, Years -> Days, Weeks.

=== !

[quote, Junior Developer via E-Mail, 2018]
____
"We don't have time to write tests."
____

[NOTE.speaker]
====
Working for a year without completing a feature

vs

1st Commit on 2nd day of work and huge refactoring after 6 months.
====

=== Beware of the Specification

http://www.commitstrip.com/en/2016/08/25/a-very-comprehensive-and-precise-spec/

=== But also

http://dilbert.com/strip/2016-03-06

== Menschen

=== Melonen Projekte

=== Werte von XP

=== Einfachheit

=== Feedback

=== Mut

=== Respekt

=== Kommunikation

=== Der Fisch stinkt vom Kopf aus

[quote, Peter Drucker(?)]
____
Culture Eats Strategy for Breakfast
____

== Fallstricke.

=== "Agile löst unsere Probleme."

=== Cargo Cult.

=== "Retrospektiven brauchen wir nicht."

=== "Management brauchen wir nicht mehr."

=== The complete adventurer.

[NOTE.speaker]
====
Vieles muss man erst lernen.

Das braucht Zeit und Hilfe von anderen.
====

=== Das Generationen Problem.

[NOTE.speaker]
====
Vieles muss man erst lernen.

Das braucht Zeit und Hilfe von anderen.
====

== The latest Technology Trend

=== Microservices.

[quote, Harr, NATO Software Engineering Conference 1968]
____
 We definitely need better techniques for changing a program in the field while continuing to provide service.
____

=== Codebase
One codebase tracked in revision control, many deploys

[NOTE.speaker]
====
One to one relationship between App and Repository.
====

=== Dependencies

Explicitly declare and isolate dependencies

=== !

[quote, d’Agapeyeff, NATO Software Engineering Conference 1968]
____
programming would be simplified if certain processes could be declarative rather than procedural
____

[NOTE.speaker]
====
Sagte ich Maven?
====

=== Config
Store config in the environment.

[NOTE.speaker]
====
Nicht in der Version Verwaltung.
====


=== Backing services
Treat backing services as attached resources.

[NOTE.speaker]
====
Modularisierung in Höchstform.
Wo der Service läuft ist egal und darf sich ändern ohne, dass die App etwas davon merkt.
====

===  Build, release, run
Strictly separate build and run stages

=== Processes
Execute the app as one or more stateless processes

=== Port binding
Export services via port binding

=== Concurrency
Scale out via the process model

=== Disposability
Maximize robustness with fast startup and graceful shutdown

=== Dev/prod parity
Keep development, staging, and production as similar as possible

=== Logs
Treat logs as event streams

=== Admin processes
Run admin/management tasks as one-off processes











"Only one thing seems to be clear just now. It is that program construction is not always a simple progression in which each act of assembly represents a distinct forward step and that the final product can be described simply as the sum of many sub-assemblies."

Nato document

Graham: Today we tend to go on for years, with tremendous investments to find that the system, which was not well understood to start with, does not work as anticipated. We build systems like the Wright brothers built airplanes
— build the whole thing, push it off the cliff, let it crash, and start over again.

"The need for feedback was stressed many times."

"We find that every design phase we go through we base strictly on the users’ reactions
to the previous system. The users are the people who do our design, once we get started."

"Users are interested in systems requirements and buy systems in that way. But that implies that they are able
to say what they want. Most of the users aren’t able to. One of the greatest difficulties will be out of our field as
soon as the users realize what kind of problems they have."


"I just want to make the point that reliability really is a design issue, in the sense that unless you are conscious
of the need for reliability throughout the design, you might as well give up."


== Referenzen


https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf[On the Criteria To Be Used in Decomposing Systems into Modules]

include::self.ad[]



