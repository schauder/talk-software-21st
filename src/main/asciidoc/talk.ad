= Software Entwicklung im 21. Jahrhundert
:icons: font
:twitter-tag: @jensschauder
:conference-tag:
:talk-tag: #sw21cent
:slide-link: http://bit.ly/sd-21-cent
:linkattrs:

include::footer.ad[]

== Es gibt nichts Neues!

[quote, Frei nach Radio FFN]
____

Die best Softwareengineering Tipps aus den 60ern, 70ern und 80ern
____

=== !

[quote, André Gide]
____
Everything that needs to be said has already been said. But since no one was listening, everything must be said again.
____


=== !

[quote, Morris King Udal oder Karl Valentine]
____

Everything has been said but not everyone has said it.
____

=== Wir stecken in einer Softwarekrise.

=== Die Computer sind zu groß!

[quote, Edsger Dijkstra, "The Humble Programmer (EWD340), Communications of the ACM 1972"]
____
as long as there were no machines, programming was no problem at all;
when we had a few weak computers, programming became a mild problem, and now we have gigantic computers, programming has become an equally gigantic problem.
____

=== Wie "gigantic"?

PDP-11 (1970)

1 CPU

256 kB

10 MHz

Ich nenne das 1 CSU (Computer Size Unit)

=== Mein Telefon

8 Cores

4 GB

2 GHz

8 * 4000 * 200 CSU = 64.000.000 CSU

=== Du hast einen Garten.

=== 15m x 15m

=== Du erbst.

=== 75m x 75m

Das wird zu viel!

=== Deutschland ist dein Garten!

=== Oder Europa

[NOTE.speaker]
====
if you are running in the Cloud it's the world.
====

== Software Engineering!

image::margaret-hamilton.jpg[background, size=contain]

[NOTE.speaker]
====
Margaret Hamilton coined the term to add value to the profession.

It's all about professionalizing the job.

Also invented the concept of Fault Tolerance.
====

=== Nato Conference.

=== Seit dem sind die Fortschritte erschreckend klein.

=== !

[quote, Frei nach Kevlin Henney]
____
Die IT entdeckt nicht ständig etwas Neues. Wir vergessen bloß was wir schon längst wussten und finden es dann wieder. Und geben damit an.
____


== Werkzeuge

=== IDE

=== Versions Verwaltung

[NOTE.speaker]
====
Git oder gitartige
====

=== Auch für

* Dokumentation
* Datenbankskripte
* Buildskripte

=== Issue Tracker

=== Referenzen zwischen Commits und Issues

=== Automatisierte Tests

=== Continuous Integration

=== Dependency Management

[NOTE.speaker]
====
Maven oder vergleichbares.
====

=== Haben reicht nicht.

[NOTE.speaker]
====
Man muss sie auch nutzen können.

Ohne Maus.
====

== Software Design

=== Modularisierung

=== !

[quote, Christopher Alexander, Notes on the Synthesis of Form, 1964]
____
We may therefore picture the process of formmaking as the action of a series of subsystems, all interlinked, yet sufficiently free of one another to adjust independently in a feasilbe amount of time. It works, because the cycles of correction and recorrection, which occur during adaptation, are restricted to one subsystem at a time.
____

=== !

[quote, Parnas, On the Criteria To Be Used in Decomposing Systems into Modules - 1972]
____
It is almost always incorrect to begin the decomposition
of a system into modules on the basis of a flowchart.
____

=== Flowchart einer Webapplikation

=== Package Struktur

=== !

[quote, Parnas, On the Criteria To Be Used in Decomposing Systems into Modules - 1972]
____
instead that one begins with a list of
difficult design decisions or design decisions which are
likely to change. Each module is then designed to hide
such a decision from the others.
____

[NOTE.speaker]
====
Was genau ist ein Kunde, ein Auftrag, eine Bestellung?

Irgend wann auch:

 Wie ist meine Datenbank strukturiert.
 Welche Art von Datenbank verwende ich?
====

=== Packages, Klassen, Methoden als Baum

// todo image

=== Wo ändert sich etwas?

// todo image

=== Oder so?

// todo image

=== Ein Rant in Sachen Reuse.

[NOTE.speaker]
====
Reuse ist teuer.

Es ist eine Investition.

Baut sauber strukturierte Code, dann ist reuse möglich, wenn nötig.
====

=== ~99% reuse

[NOTE.speaker]
====
We are actually pretty good at reuse
====

=== Baut mir einen PKW!

Mit Teilen von Baggern und Windfarmen.

+

15kg neue Teile.

== Prozesse, Menschen und komplexe Systeme.

=== Klassisches PM basiert auf Annahmen.

=== Zentrale Kontrolle ist möglich.

=== Design ist der schwierige Teil.

=== Die Implementierung dauert lange.

=== Viele einfache Aufgaben.

=== Viel wiederkehrende Aufgaben.

=== Wir wissen wann wir fertig sind ohne es zu benutzen.

=== Änderungen sind teuer.

=== Fast alle Annahmen sind falsch.

=== Software Development ist komplex.

[NOTE.speaker]
====
Minute details can have huge effects.

* A talk a team member watched.
* A fight a team member had at home.
* A feature that got added or not.

You can't predict the future from the past.
====

=== !

[quote, Cilliers, Paul, "Knowing Complex Systems" Managing organizational complexity : philosophy, theory and application. - Greenwich, Conn. : IAP - Information Age Pub. Inc, ISBN 1593113196. - 2005, p. 7-19]
____
There is no accurate (or rather, perfect) representation of the system which is simpler than the system itself.
____

=== Design ist tatsächlich schwierig.

[NOTE.speaker]
====
The largest part of software design happens during coding.
====

=== Die Implementierung ist einfach.

Wir nennen es kompilieren.

=== !

[quote, NATO Software Engineering Conference 1968]
____
The replication of multiple copies of a software system is the phase of software manufacture which corresponds to the production phase in other areas of engineering.
____

=== Kaum einfache Aufgaben.

=== Kaum wiederkehrende Aufgaben.

[NOTE.speaker]
====
Simple repetitive tasks get bundled into two tasks.

- creating a generic solution.
- using the solution.

One task is pretty hard, the other is trivial and is done while slurping the morning coffee.
====

=== Software ist fertig wenn sie genutzt wird.

[NOTE.speaker]
====
Verification: Matches specification.
Validation: Is fit for intended use.
====

=== Änderungen können preiswert sein.

[NOTE.speaker]
====
Tests and clean code
====

== Alternativen

=== !


[quote, E. E. David, NATO Software Engineering Conference, 1968]
____
Define a subset of the system which is small enough to bring to an operational state [...] then build on that subsystem.
____

=== Iterativ und Inkrementell

=== Vermeidet parallele Arbeit.

=== Laufenburg Bridge

[NOTE.speaker]
====
Lot's of planning which tried to solve a difficult problem (aligning a marble slab in Amsterdam with a rock in Switzerland).
And got it wrong.
If you build just from one side the problem goes away because you can aim at the target height directly.
In software this is very often rather easy.
====

=== Einfachheit

[quote, Kent Beck, Extreme Programming explained]
____
What is the simplest thing that could possibly work?
____

=== Feedback

[quote, NATO Software Engineering Conference 1968]
____
The need for feedback was stressed many times.
____

=== !

[quote, Alan Perlis]
____
A software system can best be designed if the testing is interlaced with the designing instead of being used after the design.
____

=== !

[quote, NATO Software Engineering Conference 1968]
____
1. Flowchart until you think you understand the problem.
2. Write code until you realize that you don’t.
3. Go back and re-do the flowcharting.
4. Write some more code and iterate to what you feel is the correct solution.
____

=== Unit Tests statt ausprobieren.

Minuten -> Sekundenbruchteile.

=== Integration Tests statt of manueller Tests.

Wochen, Monate -> Sekunden.

=== Retrospektiven

Monate, Jahre -> Wochen.

=== Standups.

??? -> 1 Tag.

=== Häufige Deployments.

Monate, Jahre -> Tage, Wochen.

=== !

[quote, Junior Developer via E-Mail, 2018]
____
"We don't have time to write tests."
____

[NOTE.speaker]
====
Working for a year without completing a feature

vs

1st Commit on 2nd day of work and huge refactoring after 6 months.
====

=== Vorsicht Spezifikation.

http://www.commitstrip.com/en/2016/08/25/a-very-comprehensive-and-precise-spec/

=== Aber auch.

http://dilbert.com/strip/2016-03-06

== Menschen.

=== Melonen Projekte.

=== Werte von XP.

=== Einfachheit.

=== Feedback.

=== Mut.

=== Respekt.

=== Kommunikation.

=== Der Fisch stinkt vom Kopf aus.

[quote, Peter Drucker(?)]
____
Culture Eats Strategy for Breakfast
____

=== Wie rettet man einen Kerbal?

== Fallstricke.

=== "Agile löst unsere Probleme."

=== Cargo Cult.

=== "Retrospektiven brauchen wir nicht."

=== "Management brauchen wir nicht mehr."

=== The complete adventurer.

[NOTE.speaker]
====
Vieles muss man erst lernen.

Das braucht Zeit und Hilfe von anderen.
====

=== Das Generationen Problem.

[NOTE.speaker]
====
Vieles muss man erst lernen.

Das braucht Zeit und Hilfe von anderen.
====

== Microservices.

[quote, Doug McIlroy]
____
This is the Unix philosophy: Write programs thata do one thing and do it well.
____

=== Unabhängiges Deployment.

[quote, Harr, NATO Software Engineering Conference 1968]
____
 We definitely need better techniques for changing a program in the field while continuing to provide service.
____

=== Late binding.

[quote, Alan Kay]
____
OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things.
____


[quote, Wikipedia]
____
The term "late binding" dates back to at least the 1960s, where it can be found in Communications of the ACM. The term was widely used to describe calling conventions in languages like Lisp, though usually with negative connotations about performance.
____

[NOTE.speaker]
====
Again the 60s.

Note the correlation to performance.
====

=== Concurrency

[quote, Russel Winder, Message Passing Leads to Better Scalability in Parallel Systems"]
____
Languages such as Erlang (and occam before it) have shown that processes are a very successful mechanism for programming concurrent and parallel systems.
____


=== Reliability.

[quote, NATO Software Engineering Conference 1968]
____
I just want to make the point that reliability really is a design issue, in the sense that unless you are conscious
of the need for reliability throughout the design, you might as well give up.
____

=== Fehlertoleranz.

Margaret Hamilton für Apollo 11.

Actor Model (1973)

=== Dependency Management

[quote, Clemens Szyperski, "Component Software Beyond Object-Oriented Programming"]
____
A software component is a unit of composition with contractually specified interfaces and explicit context dependencies only.
____

[quote, Clemens Szyperski, "Component Software Beyond Object-Oriented Programming"]
____
A software component can be deployed independently and is subject ot third-party composition..
____

== !

[quote, William Gibson]
____
The future is already here -- it's just not very evenly distributed.
____

include::self.ad[]

== Referenzen

https://www.win.tue.nl/~wstomv/edu/2ip30/references/criteria_for_modularization.pdf[On the Criteria To Be Used in Decomposing Systems into Modules]

http://www.scrummanager.net/files/nato1968e.pdf[Software Engineering, Report on a conference sponsored by the NATO SCIENCE COMMITTEE]




